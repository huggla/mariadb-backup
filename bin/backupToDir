#!/bin/sh
cd /
set -e +a +m +s +i -f

commandForBackupToDir(){
   local backupDir=$1
   local IFS=$(echo -en "\n\b,")
   local database=""
   local dumpCmd="find \"$backupDir/\" -mindepth 1 -maxdepth 1 -type d -exec rm -r {} \;"
   local delimiter='&&'
   local format=""
   local file=""
   local jobs=""
   local clean=""
   local xschemas=""
   local xschema=""
   local schemas=""
   local schema=""
   local xtables=""
   local xtable=""
   local tables=""
   local table=""
   if [ -z "$VAR_DATABASES" ]
   then
      dumpCmd="/usr/local/bin/mysqldump --defaults-extra-file=/run/mysqldumpPw --host=$VAR_HOST --port=$VAR_PORT --user=$VAR_LINUX_USER --all-databases"
   else
      for database in $VAR_DATABASES
      do
         database="$(trim $database)"
         file="$backupDir/$database"
         dumpCmd="$dumpCmd $delimiter /usr/local/bin/mysqldump --defaults-extra-file=/run/mysqldumpPw --host=$VAR_HOST --port=$VAR_PORT --user=$VAR_LINUX_USER --tab=$file"
         eval "drop=\$VAR_$database_dropdb"
         if [ "$drop" != "no" ]
         then
            if [ "$drop" == "yes" ] || [ "$VAR_DROP" == "yes" ]
            then
               dumpCmd="$dumpCmd --add-drop-trigger"
            fi
         fi
         eval "nodata=\$VAR_$database_nodata"
         if [ "$nodata" != "no" ]
         then
            if [ "$nodata" == "yes" ] || [ "$VAR_NODATA" == "yes" ]
            then
               dumpCmd="$dumpCmd --no-data"
            fi
         fi
         eval "igntables=\$VAR_$database_igntables"
         for table in $igntables
         do
            table="$(trim table)"
            dumpCmd="$dumpCmd --ignore-table=$table"
         done
         dumpCmd="$dumpCmd $database"
         eval "tables=\$VAR_$database_tables"
         for table in $tables
         do
            table="$(trim table)"
            dumpCmd="$dumpCmd $table"
         done
         for table in $VAR_TABLES
         do
            table="$(trim table)"
            dumpCmd="$dumpCmd $table"
         done
      done
   fi
   echo "$dumpCmd"
}

recursiveDeleteFileDuplicates(){
   local -
   local dir="."
   local dirName=""
   if [ -n "$1" ]
   then
      dir=$1
   else
      dirName="$(/usr/bin/basename "$(/bin/pwd)")"
      if [ ! -e "$dir/latest" ] || [ "$(/usr/bin/readlink "$dir/latest")" == "./$dirName" ]
      then
         return
      fi
   fi
   local backupFile=""
   set +f
   for backupFile in "$dir/"*
   do
      if [ -f "$backupFile" ]
      then
         if [ ! "$(/usr/bin/cmp "$backupFile" "../latest/$backupFile")" ]
         then
            /bin/rm "../latest/$backupFile"
         fi
      elif [ -d "$backupFile" ]
      then
         recursiveDeleteFileDuplicates "$backupFile"
      fi
   done
}

linkDirAsLatest(){
   local backupDir=$1
   cd "$backupDir/.."
   rm -f ./latest
   /bin/ln -s "./$(/usr/bin/basename "$backupDir")" "./latest"
}

[ $(type -t readEnvironmentVars) ] || . /start/functions/readEnvironmentVars
[ $(type -t runBinCmdAsLinuxUser) ] || . /start/functions/runBinCmdAsLinuxUser
[ $(type -t execCmdAsLinuxUser) ] || . /start/functions/execCmdAsLinuxUser
[ $(type -t trim) ] || . /start/functions/trim

#-----------------------------------------------------------------------------

backupDir="$1"
readEnvironmentVars
/bin/mkdir -m 700 -p "$backupDir"
/bin/chown $VAR_LINUX_USER "$backupDir"
backupCmd="$(commandForBackupToDir "$backupDir")"
if [ -n "$backupCmd" ]
then
   set +f
   eval "$backupCmd"
   set -f
   if [ "$VAR_DELETE_DUPLICATES" == "yes" ] && [ -d "$backupDir/../latest" ]
   then
      cd "$backupDir"
      recursiveDeleteFileDuplicates
   fi
   linkDirAsLatest "$backupDir"
fi
